package netork;

/**
 * 四种主要的IO模型
 *
 *  同步阻塞IO 即BIO
 *     一个线程维护一个IO流的读写（线程数量 和 效率 是抛物线的关系），
 *     BIO模型在高并发场景下是不可用的（创建多个 以及线程上下文切换耗资源）
 *  （同步指的是等待数据就绪  等待把内核缓冲区数据写到用户缓冲区，等待的过程也是阻塞的过程）
 *
 * 同步非阻塞 NIO（和BIO差别不大  不太用）
 *    socket可以设置为non-blockingw
 * 发起系统调用时：
 *   1）在内核缓冲区 没有 数据的情况下，会立即返回一个调用失败的信息
 *   2）在内核缓冲区 有   数据的情况下，是阻塞的。直到内核缓冲区的数据全部复制到进程缓冲区，系统调用成功
 * NIO特点：
 *   每次的IO调用，在内核数据未就绪的情况下，应用程序需要不停地进入IO调用，轮询查看数据是否就绪，
 *   如果没有就绪，继续轮询；如果就绪，才会返回
 * 优点：
 *   内核缓冲区没有数据的情况下，发起的系统调用不会阻塞，用户程序不会阻塞
 * 缺点：
 *   需要 不断地 重复地发起IO调用，这种不断轮询，不断询问内核的方式，会占用CPU大量的时间，资源利用率比较低；
 *   在内核缓冲区有数据的情况下，也是阻塞的
 *   NIO模型在高并发场景下是 不可用 的，这里的NIO模型（是操作系统的） 并非  Java库中NIO库（其实是IO多路复用）
 *
 *
 *
 * IO多路复用
 *    通过 一个新的系统调用：select/epoll（通用性比较强）系统调用， 可以实现一个进程监视多个文件描述符（即socket链接），
 *    一旦某个描述符就绪(表示内核缓冲区可读/可写)，内核能够通知用户程序进行IO系统调用。
 *
 *   以线程为例：单个线程 不断的轮询select/epoll系统调用所负责多个socket连接，
 *   当某个socket连接有数据到达，就返回这些可以读写的连接。
 * 特点：
 *   与NIO模型类似，多路复用IO需要 轮询  负责select/epoll查询调用的 线程，查找出可以进行IO操作的连接，
 *   对于每一个可以查询的socket，一般需要设置为non-blocking
 * 优点：
 *   select/epoll可以同时处理成百上千的连接，
 *   与之前的一个线程维护一个连接相比，IO多路复用则不需要创建线程，也就不需要维护，从而减少系统开销
 * 缺点：
 *   对于select/epoll系统调用来说，属于阻塞？？？？？？的模式，同步IO。
 *   读写事件就绪之后，用户自己进行读写，这个读写过程也是阻塞？？？？的
 *
 *（了解： select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。
 * 调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。
 * 当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。）
 *
 *
 * 异步IO AIO
 *    用户线程通过系统调用，告知内核启动某个IO操作，用户线程直接返回。
 *    内核在整个IO操作(数据准备，数据复制)完成之后，通知用户程序，用户程序再执行后续的业务操作
 * 特点：
 *   分为两个等待过程，等待数据就绪，等待数据拷贝，而在这两个等待过程中用户线程都不是block的，等这两个操作完成之后，用户线程就会收到一个信号。
 *   所以AIO又称之为 信号驱动IO
 * 缺点：
 *   需要事件的注册，就需要操作系统（linux系统的异步IO还不太成熟   多用IO多路复用模型）
 * 优点：
 *   不用阻塞  直接返回   等待过程中自己可以做其他事情
 *
 *
 */
public class Teacher_3_13_IO {
    public static void main(String[] args) {

    }
}
